# 任务一：ECMAScript 新特性
## 1-5 let与块级作用域
1. 作用域：某个成员能起作用的范围
2. ES2015前只有函数作用域和全局作用域 
3. ES2015新增块级作用域
4. 通过let声明块级作用域变量
5. var声明的变量会自动提升
   
## 1-6 const
1. 在let的基础上增加了[只读]特性
2. const变量声明后不允许再被修改
3. 只是不能再被指向新的内存地址，const声明的对象变量中的属性可修改
4. 最佳实践：不用var，主用const，配合了let

## 1-7 数组的结构
1. 解构数量相等
  ```javascript
  const arr = [100,200,300]
  const [foo ,bar ,baz] = arr
  console.log(foo,bar,baz)
  // 100 200 300
  ```
2. 留白占位
  ```javascript
  const arr = [100,200,300]
  const [,,baz] = arr
  console.log(baz)
  // 300
  ```
3. 扩展运算符，只能用在最后，表示囊括数组剩余所有数据，类型为集合
  ```javascript
  const arr = [100,200,300]
  const [foo , ...rest] = arr
  console.log(rest)
  // [ 200, 300 ]
  ```
4. 设置默认值，用于长度超出，否则为undefined
  ```javascript
  const arr = [100,200,300]
  const [foo ,bar ,baz = 400 ,more = 600] = arr
  console.log(foo,bar,baz,more)
  // 100 200 300 600
  ```
5. 应用场景：拆分字符串并获取指定位置
  ```javascript
  const path = 'foo/bar/baz'
  const [,bar,] = path.split('/')
  console.log(bar)
  // bar
  ```

## 1-8 对象的结构
1. 根据属性名获取对应值
2. 其他情况与数组解构类似，例如设置默认值等
3. 变量名冲突时，可用重命名方式解决,也可以同时设置默认值
  ```javascript
  const obj = {name: 'Jack', age: 18}
  const name = 'Tom'
  const { name: objName = 'Rose' } = obj
  console.log(name, objName)
  // Tom Jack
  ```
4. 解构常用方法，简化代码
  ```javascript
  const { log } = console
  log('hello')
  // hello
  ```

## 1-9 模板字符串
1. 支持直接换行
2. 支持插值表达式，嵌入变量
  ```javascript
  const name = 'Tom'
  const msg = `hey, ${name}`
  console.log(msg)
  // hey, Tom
  ```
3. 支持嵌入合法js表达式
  ```javascript
  const name = 'Tom'
  const msg = `hey, ${name}---${1 + 2 + 3}`
  console.log(msg)
  // hey, Tom---6
  ```

## 1-10 带标签的模板字符串
1. 对模板字符串进行预加工，strings参数会根据嵌入变量拆分为string数组
  ```javascript
  const name = 'Tom'
  const gender = 'male'

  function myTag(strings , param1 , param2){
    console.log(strings, param1, param2)
  }
  const result = myTag`hello, ${name} is a ${gender}!`
  // [ 'hello, ', ' is a ', '!' ] Tom male
  ```
2. 可进行预处理，预判断或实现一个模板引擎等操作

## 1-11 字符串的扩展方法(便捷字符串查找)
1. startsWith
  ```javascript
  const msg = 'Error: foo is undefined'
  console.log(
    msg.startsWith('Error')
  )
  // true
  ```
2. endsWith
  ```javascript
  const msg = 'Error: foo is undefined'
  console.log(
    msg.endsWith('.')
  )
  // true
  ```
3. includes
  ```javascript
  const msg = 'Error: foo is undefined'
  console.log(
    msg.includes('foo')
  )
  // true
  ```

## 1-12 参数默认值
1. 默认值仅在未传递实参时被使用
  ```javascript
  function test(foo, enable = true){
    console.log(foo, enable)
  }

  test('abc')
  // abc true
  ```
2. 带有默认值的参数需放在最后


## 1-13 剩余参数
1. 通过扩展运算符接受剩余参数，取代arguments
  ```javascript
  function foo(...args){
    console.log(args)
  }
  foo(1, 2, 'a', {name: 'tom', height: 170})
  // [ 1, 2, 'a', { name: 'tom', height: 170 } ]
  ```
2. 只能出现在形参的最后一位，且只能使用一次

## 1-14 展开数组
1. 通过扩展运算符将数组成员按顺序传入参数列表中
  ```javascript
  const arr = ['foo', 'bar', 'baz']
  // console.log.apply(console, arr) 等效方法
  console.log(...arr)
  // foo bar baz
  ```

## 1-15 箭头函数
1. 简化函数回调的编写, 函数体为单行且未加花括号时默认为返回值
  ```javascript
  const arr = [1, 2, 3, 4, 5, 6, 7]
  // const newArr = arr.filter(function (item) {
  //   return item % 2
  // })
  const newArr = arr.filter(i => i % 2)

  console.log(newArr)
  // [ 1, 3, 5, 7 ]
  ```

## 1-16 箭头函数与this
1. 箭头函数不会改变this的指向，即箭头函数外部的this是啥，箭头函数内部拿到的this就是啥
  ```javascript
  const person = {
    name: 'Tom',
    sayHi: () => {
      console.log(this.name)
    },
    sayHiAsync: function (){
      setTimeout(() => {
        console.log(this.name)
      }, 1000)
    }
  }

  person.sayHi()
  person.sayHiAsync()
  //undefined
  //Tom
  ```

## 1-17 对象字面量的增强
1. 可在对象中直接引入变量作为属性，属性名与变量名一致
2. 为对象添加普通方法，可省略冒号和function,方法中调用的this将指向当前对象
3. 计算属性名。可使用动态值作为属性名，用方括号包起。
  ```javascript
  const bar = 'abc'
  const obj = {
    foo: 123,
    bar,// 1
    method1() {
      console.log('method123')
      console.log(this)
    },// 2
    [Math.random()]: 'random'// 3
  }
  console.log(obj)
  //{
  //  foo: 123,
  //  bar: 'abc',
  //  method1: [Function: method1],
  //  '0.18797853632805395': 'random'
  //}
  ```

## 1-18 对象扩展方法 Object.assign
1. 将多个源对象中的属性复制到一个目标对象中，返回值与第一个目标对象完全等同
  ```javascript
  const source1 = {
    a: '123',
    b: '234'
  }
  const source2 = {
    c: 789,
    d: 100
  }
  const target = {
    a: 'abc',
    c: 'def'
  }
  const result = Object.assign(target, source1, source2)
  console.log(target, target === result)
  // { a: '123', c: 789, b: '234', d: 100 } true
  ```
2. 可在方法中复制出一个新对象，从而不改变原有对象的值

## 1-19 对象扩展对象 Object.is
1. 可严格区分+0与-0，以及判定NaN
  ```javascript
  console.log(Object.is(+0,-0))
  console.log(Object.is(NaN,NaN))
  // false
  // true
  ```

## 1-20 Proxy
1. 为对象设置访问代理器，监视对象中属性的读写过程
  ```javascript
  const person = {
    name: 'jack',
    age: 18
  }

  const personProxy = new Proxy(person, {
    get(target, property){
      // console.log(target, property)
      // return 100
      return property in target ? target[property] : 'default'
    },
    set(target, property, value) {
      if(property === 'age'){
        if(!Number.isInteger(value)) {
          throw new TypeError(`${value} is not an int`)
        }
      }
      target[property] = value
    }
  })

  personProxy.age = 20
  personProxy.gender = 'male'
  console.log(personProxy.name)
  console.log(personProxy.height)
  console.log(person)
  // jack
  // default
  // { name: 'jack', age: 20, gender: 'male' }
  ```
   
## 1-21 Proxy对比defineProperty
1. defineProperty只能监听到对象属性的读取或写入操作，Proxy能监听到更多对象操作，例如delete操作和对象中方法的调用
  ```javascript
  const person = {
    name: 'jack',
    age: 18
  }

  const personProxy = new Proxy(person, {
    deleteProperty(target, property){
      console.log(`${property} is deleted`)
      delete target[property]
    }
  })

  delete personProxy.age
  console.log(person)
  // age is deleted
  // { name: 'jack' }

  const list = []
  const listProxy = new Proxy(list, {
    set(target, property, value) {
      console.log(target, property, value)
      target[property] = value
      return true
    }
  })

  listProxy.push(123)
  // [] 0 123
  // [ 123 ] length 1
  // 可以看到这边输出了两条打印结果，第二次为数组自身length更新操作，同样也能被监听到。
  ```
  
2. Proxy以非侵入的方式监管了对象属性的读写，defineProperty需要通过特定的方式单独定义对象中需要被监听的属性。
3. [Proxy中所有的handler方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
   |handler方法|触发方法|
   |----------|-------|
   |getPrototypeOf|Object.getPrototypeOf|
   |setPrototypeOf|Object.setPrototypeOf|
   |isExtensible|Object.isExtensible|
   |preventExtensions|Object.preventExtensions|
   |getOwnPropertyDescriptor|Object.getOwnPropertyDescriptor|
   |defineProperty|Object.defineProperty|
   |has|in 操作符|
   |get|属性读取操作|
   |set|属性设置操作|
   |deleteProperty|delete 操作符|
   |ownKeys|Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器|
   |apply|函数调用操作|
   |construct|new 操作符|


## 1-22 Reflect
1. 提供统一的一套对象操作api，提升开发体验
  ```javascript
  const person = {
    name: 'tom',
    age: 20
  }

  // console.log('name' in person)
  // console.log(delete person.name)
  // console.log(Object.keys(person))
  // 等价于以上三个操作
  console.log(Reflect.has(person, 'name'))
  console.log(Reflect.deleteProperty(person, 'name'))
  console.log(Reflect.ownKeys(person))
  // true
  // true
  // [ 'age' ]
  ```
2. reflect属于静态类，不能通过new的方式去构建一个实例对象，只能去调用其中的一些静态方法
3. Reflect成员方法就是Proxy处理对象的默认实现
  ```javascript
  const obj = {
    name: 'tom',
    age: 20
  }
  const objProxy = new Proxy(obj, {
    get(target, property) {
      console.log('watch logic')
      return Reflect.get(target, property)// 默认执行方法
    }
  })
  console.log(objProxy.name)
  // watch logic
  // tom
  ```

## 1-23 Promise
1. 提供了更优的异步编程解决方案，解决了传统异步编程中回调函数嵌套过深的问题

## 1-24 class 类
1. 声明类型，更容易理解，结构更清晰
  ```javascript
  class Person { 
    constructor(name) {
      this.name = name
    }
    say() {
      console.log(`hello, my name is ${this.name}`)
    }
  }

  const person = new Person('tom')
  person.say()
  // hello, my name is tom
  ```

## 1-25 静态方法
1.  静态方法挂载到类型上，所以在静态方法内部，this不会指向某个实例对象，而是当前的类型
  ```javascript
  class Person { 
    constructor(name) {
      this.name = name
    }
    say() {
      console.log(`hello, my name is ${this.name}`)
    }

    static create() {
      return new Person('tom')
    }
  }

  const person = Person.create()
  person.say()
  // hello, my name is tom
  ```

## 1-26 类的继承
1. extends，通过super调用父类的属性和方法
  ```javascript
  class Person { 
    constructor(name) {
      this.name = name
    }
    say() {
      console.log(`hello, my name is ${this.name}`)
    }

    static create() {
      return new Person('tom')
    }
  }

  class Student extends Person {
    constructor(name, number) {
      super(name)
      this.number = number
    }

    hello() {
      super.say()
      console.log(`my school number is ${this.number}`)
    }
  }

  const student = new Student('jack', 999)
  student.hello()
  // hello, my name is jack
  // my school number is 999
  ```

## 1-27 Set数据结构
1. 与传统数组类似，但是内部成员**不允许重复**
2. add方法会返回对象本身，所以支持链式调用
3. 可应用于数组去重
  ```javascript
  const s = new Set()
  s.add(1).add('jack').add(true).add({name: 'tom'})
  console.log(s)// Set { 1, 'jack', true, { name: 'tom' } }
  s.forEach(item => console.log(item))
  for(let item of s) {
    console.log(item)
  }
  console.log(s.size)// 4

  // 常用方法
  console.log(s.has(2))// 判断存在 false
  console.log(s.delete('jack'))// 删除对象 true
  s.clear()// 清空集合
  console.log(s)// Set {}

  // 数组去重
  const arr = [1, 2, 3, 4, 2, 3]
  // const result = Array.from(new Set(arr))
  // 与Array.from等价
  const result = [...new Set(arr)]
  console.log(result)// [ 1, 2, 3, 4 ]
  ```

## 1-28 Map数据结构
1. 与对象非常类似，本质上都是键值对集合，但是对象的键值只能是string类型（和Symbol类型），Map则支持任意类型键值
2. Map遍历时，**value在前，key在后**
  ```javascript
  const m = new Map()
  const person = {name: 'tom'}
  m.set(person, 100)
  console.log(m)// Map { { name: 'tom' } => 100 }

  console.log(m.get(person))// 100

  // 常用方法与Set一致
  // m.has()
  // m.delete()
  // m.clear()

  m.forEach((value, key) => {
    console.log(value, key)// 100 { name: 'tom' }
  })
  ```

## 1-29 Symbol及补充
1. 全新的原始数据类型
2. 通过Symbol创建的值都是唯一的
3. 可用于创建对象的私有成员
4. 目前最主要的作用是为对象添加独一无二的属性名
  ```javascript
  console.log(Symbol() === Symbol())// false
  console.log(Symbol('abc'))// 接受一个字符串作为值的描述文本
  console.log(Symbol('abc') === Symbol('abc'))// false

  const name = Symbol()
  const obj = {
    [name]: 'tom',
    age: 18
  }
  console.log(obj)// { age: 18, [Symbol()]: 'tom' }
  console.log(obj[name])// tom
  // 文件外部将无法再访问name属性
  ```
5. 提供了静态方法**for**以实现两个相同的Symbol值，会将传入参数转化为**string类型**
  ```javascript
  const s1 = Symbol.for('foo')
  const s2 = Symbol.for('foo')
  console.log(s1 === s2)// true
  console.log(Symbol.for(true) === Symbol.for('true'))// true
  ```
6. 使用Symbol作为属性名，通过传统的for in循环、Object.keys（获取所有的string属性名）、Json.stringify都无法拿到，可通过Object.getOwnPropertySymbols获取到对象中所有的Symbol属性。


## 1-31 for···of循环
1. 作为遍历所有数据结构的统一方式
2. 可以使用break终止循环，forEach方法无法终止遍历
  ```javascript
  const m = new Map()
  m.set('foo', '123')
  m.set('bar', 'abc')
  for(let [key, value] of m){
    console.log(key, value)
  }
  // foo 123
  // bar abc
  ```

## 1-32 可迭代接口
1. 所有可以直接被for of 循环的数据类型都必须在内部实现iterator的接口，在内部需要挂在iterator方法，该方法会返回一个带有next方法的对象，通过不断调用next方法实现对数据内部的遍历
  ```javascript
  const s = ['123', '456', '789']
  const iterator = s[Symbol.iterator]()

  console.log(iterator.next())// { value: '123', done: false }
  console.log(iterator.next())// { value: '456', done: false }
  console.log(iterator.next())// { value: '789', done: false }
  console.log(iterator.next())// { value: undefined, done: true }
  // for···o遍历的实现原理
  ```

## 1-33 实现可迭代接口（Iterable）
1. 可迭代接口：Iterable，内部必须要有一个用于返回迭代器的iterator方法，即实现了迭代器接口：Iterator，内部必须有一个用于迭代的next方法，该方法内部返回的对象，该对象实现迭代结果接口：IterationResult
  ```javascript
  // 实现可迭代接口
  const obj = {
    store: ['foo', 'bar', 'baz'],
    [Symbol.iterator]: function() {
      let index = 0
      const _this = this
      // 实现迭代器接口
      return {
        next() {
          const result = {
            value: _this.store[index],
            done: index >= _this.store.length// 迭代是否结束
          }
          index++
          // 实现迭代结果接口
          return result
        }
      }
    }
  }

  for(let item of obj) {
    console.log(item)
  }
  // foo bar baz
  ```

## 1-34 迭代器模式(Iterator)
1. 对外提供统一遍历接口，让外部不用关心数据内部结构
  ```javascript
  const todos = {
    life: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语'],
    work: ['敲代码'],
    // 之前，不具有统一性
    each: function(callback) {
      const all = [].concat(this.life, this. learn, this.work)
      for(const item of all) {
        callback(item)
      }
    },
    // 现在，等价于上面的each
    [Symbol.iterator]: function() {
      const all = [...this.life, ...this.learn, ...this.work]
      let index = 0
      return {
        next() {
          const result = {
            value: all[index],
            done: index >= all.length
          }
          index++
          return result
        }
      }
    }
  }
  // todos.each((item) => {
  //   console.log(item)
  // })

  for(const item of todos) {
    console.log(item)
  }
  // 吃饭
  // 睡觉
  // 打豆豆
  // 语文
  // 数学
  // 外语
  // 敲代码
  ```

## 1-35 生成器函数（Generator）
1. 避免异步编程中回调嵌套过深，提供更好的异步编程解决方案
2. 生成器函数会自动返回一个生成器对象，调用对象的next方法才会让函数的函数体开始执行，遇到yield关键词就会让函数的执行暂停，值会在next方法中返回。特点：惰性执行
  ```javascript
  function * foo() {
    console.log('first')
    yield 100
    console.log('second')
    yield 200
    console.log('third')
    yield 300
  }
  const generator = foo()
  console.log(generator.next())// first, { value: 100, done: false }
  console.log(generator.next())// second, { value: 200, done: false }
  console.log(generator.next())// third, { value: 300, done: false }
  console.log(generator.next())// { value: undefined, done: true }
  ```

## 1-36 生成器应用
  ```javascript
  const todos = {
    life: ['吃饭', '睡觉', '打豆豆'],
    learn: ['语文', '数学', '外语'],
    work: ['敲代码'],

    [Symbol.iterator]: function * () {
      const all = [...this.life, ...this.learn, ...this.work]
      for(const item of all) {
        yield item
      } 
    }
  }

  for(const item of todos) {
    console.log(item)
  }
  // 吃饭
  // 睡觉
  // 打豆豆
  // 语文
  // 数学
  // 外语
  // 敲代码
  ```

## 1-37 Modules
1. 语言层面的模块化标准，模块化开发中详细介绍

## 1-38 ES2016概述
1. Array.prototype.ncludes， 检查包含指定元素
  ```javascript
  const arr = ['foo', 'baz', NaN]
  console.log(arr.indexOf('foo'))// 0
  console.log(arr.indexOf(NaN))// -1，即indexOf方法无法判断NaN的存在
  console.log(arr.includes('bat'))// false
  console.log(arr.includes(NaN))// true
  ```
2. 指数运算符 **
  ```javascript
  console.log(Math.pow(2, 10))// 1024
  console.log(2 ** 10)// 1024
  ```

## 1-39 ES2017概述
1. Object.values，返回对象中所有的值组成的数组
  ```javascript
  const obj = {
    foo: 'value1',
    bar: 'value2'
  }
  console.log(Object.values(obj))
  // [ 'value1', 'value2' ]
  ```
2. Object.entries，数组形式返回对象中所有的键值对
  ```javascript
  const obj = {
    foo: 'value1',
    bar: 'value2'
  }
  for(const [key, value] of Object.entries(obj)) {
    console.log(key, value)
  }
  // foo value1
  // bar value2
  // 转Map类型对象
  console.log(new Map(Object.entries(obj)))
  // Map { 'foo' => 'value1', 'bar' => 'value2' }
  ```
3. Object.getOwnPropertyDescriptors，获取对象中所有属性，包括get、set方法
  ```javascript
  const person = {
    firstName: 'tom',
    lastName: 'kent',
    get fullName() {
      return this.firstName + this.lastName
    }
  }

  const personProperty = Object.getOwnPropertyDescriptors(person)
  const newPerson = Object.defineProperties({}, personProperty)
  console.log(newPerson)// { firstName: 'tom', lastName: 'kent', fullName: [Getter] }
  newPerson.lastName = 'jack'
  console.log(newPerson.fullName)// tomjack
  ```
4. String.prototype.padStart 和 tring.prototype.padEnd，可用于数字的补零以及对其字符串
  ```javascript
  const books = {
    js: 12,
    html: 25,
    css: 128
  }

  for(const [name, count] of Object.entries(books)) {
    console.log(`${name.padEnd(10, '-')}|${count.toString().padStart(3, '0')}`)
  }
  // js--------|012
  // html------|025
  // css-------|128
  ```

# 任务二：JavaScript异步编程
## 2-1 概述
1. 单线程模式工作，JS执行环境中负责执行代码的线程只有一个
2. 为解决耗时操作引起的阻塞假死的问题，JS将任务的执行模式分为了两种：
   - 同步模式（Synchronous）
   - 异步模式（Asynchronous）
  
## 2-2 同步模式（Synchronous）
1.  代码中的任务依次执行，后面的任务需等待前一个任务执行完毕。程序执行顺序与代码编写顺序一致
2.  容易产生阻塞的问题

## 2-3 异步模式（Asynchronous）
1. Call Stack => Web APIs => Queue => Call Stack ...
2. 异步模式流程
  ![异步模式](https://raw.githubusercontent.com/ALLTAKENS/MarkDownImg/master/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F.jpeg)
3. 内部的api，例如倒计时，浏览器会用一个单独的线程去执行
4. 这边讨论的同步和异步方式是指运行环境提供的API是以同步或异步模式方式工作

## 2-4 回调函数
1. 所有异步编程方案的根基
2. 回调函数可以理解成一件你想要做的事情，我们知道事情该怎么做但是不清楚它何时做完，异步函数可以帮助在事情做完时通知我们。

## 2-5 Promise概述
1. Promise => Pending => Fulfilled || Rejected

## 2-6 Promise基本用法
1. 
  ```javascript
    const promise = new Promise((resolve, reject) => {
      // resolve(100)
      reject(new Error('promise rejected'))
    })

    promise.then((res) => {
      console.log(res)
    }, (err) => {
      console.log(err)
    })

    console.log('end')
    /**
     * end
      Error: promise rejected
        at 01-02.js:6
          at new Promise (<anonymous>)
          at Object.<anonymous> (01-02.js:4)
          at __webpack_require__ (bootstrap:19)
          at Object.<anonymous> (bootstrap:83)
          at __webpack_require__ (bootstrap:19)
          at bootstrap:83
          at bootstrap:83
     * /
   ```

## 2-7 Promise使用案例
1. 封装ajax
  ```javascript
  function ajax(url) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest()
      xhr.open('GET', url)
      xhr.responseType = 'json'
      xhr.onload = function() {
        if(this.status === 200) {
          resolve(this.response)
        } else {
          reject(new Error(this.statusText))
        }
      }
      xhr.send()
    })
  }

  ajax('/api/users.json').then(res => {
    console.log(res)
  }, err => {
    console.log(err)
  })
  // {name: "tom", age: 18}
  ```

## 2-8 Promise常见误区
1. 借助于Promise then方法链式调用的特点，尽可能保证异步任务扁平化

## 2-9 Promise链式调用
1. Promise的then方法返回的都是一个新的Promise对象，
2. 后面的then方法就是在为上一个then返回的Promise注册回调
3. 前面then方法中回调函数的返回值会作为后面then方法回调的参数
4. 如果回调中返回的是Promise，那后面then方法的回调会等待它的结束
  ```javascript
  ajax('/api/users.json')
    .then(res => {
      console.log(res)
    })
    .then(res => {
      console.log('---------------')
      console.log('111')
      return ajax('/api/users.json')
    })
    .then(res => {
      console.log('---------------')
      console.log(res)
      console.log('222')
      return 'foo'
    })
    .then(res => {
      console.log('---------------')
      console.log(res)
      console.log('333')
    })
    /**
     * {name: "tom", age: 18}
    * ---------------
    * 111
    * ---------------
    * {name: "tom", age: 18}
    * 222
    * ---------------
    * foo
    * 333
    */
  ```